<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Gesture Morph Engine | Mobile Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', system-ui, sans-serif; touch-action: none; }
        #ui { position: absolute; top: 20px; left: 20px; right: 20px; color: #fff; z-index: 100; pointer-events: none; }
        .panel { background: rgba(0, 0, 0, 0.7); border: 1px solid rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 12px; backdrop-filter: blur(10px); }
        h1 { margin: 0; font-size: 1rem; color: #ff0055; }
        #status { font-size: 0.8rem; margin-top: 5px; color: #00f2ff; }
        
        /* Mobile Start Overlay */
        #setup-overlay {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center; padding: 30px;
        }
        .btn {
            background: #ff0055; color: white; border: none; padding: 16px 32px;
            font-size: 1rem; border-radius: 50px; font-weight: bold; margin-top: 20px;
            cursor: pointer; pointer-events: auto;
        }
        .error-box { color: #ff4444; font-size: 0.9rem; margin-top: 20px; display: none; }
        #video-input { position: absolute; visibility: hidden; width: 0; height: 0; }
    </style>
</head>
<body>

<div id="setup-overlay">
    <h2>3D Gesture Engine</h2>
    <p>Camera access requires <b>HTTPS</b> or <b>Localhost</b>.</p>
    <button class="btn" id="activate-cam">START EXPERIENCE</button>
    <div id="err-display" class="error-box"></div>
</div>

<div id="ui">
    <div class="panel">
        <h1 id="mode-name">SYSTEM READY</h1>
        <div id="status">WAITING FOR CAMERA...</div>
    </div>
</div>

<video id="video-input" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    const particleCount = 12000; // Balanced for mobile
    let currentMode = 'cloud';
    let targetRotationY = 0;
    const statusText = document.getElementById('status');
    const modeLabel = document.getElementById('mode-name');

    // 1. VOLUMETRIC TEXT DATA
    function generateTextPoints(text) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 400; canvas.height = 100;
        ctx.fillStyle = 'white';
        ctx.font = 'bold 40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(text, 200, 60);
        const data = ctx.getImageData(0, 0, 400, 100).data;
        const pts = [];
        for (let y = 0; y < 100; y += 3) {
            for (let x = 0; x < 400; x += 3) {
                if (data[(y * 400 + x) * 4] > 128) {
                    for (let z = -1; z <= 1; z++) {
                        pts.push({ x: (x - 200) * 0.06, y: (50 - y) * 0.06, z: z * 0.4 });
                    }
                }
            }
        }
        return pts;
    }
    const textPoints = generateTextPoints("I LOVE YOU");

    // 2. THREE.JS ENGINE
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: false }); 
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 12;

    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount * 3);
    const cloudT = new Float32Array(particleCount * 3);
    const heartT = new Float32Array(particleCount * 3);
    const flowerT = new Float32Array(particleCount * 3);
    const textT = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        cloudT[i3] = (Math.random() - 0.5) * 35;
        cloudT[i3+1] = (Math.random() - 0.5) * 35;
        cloudT[i3+2] = (Math.random() - 0.5) * 15;

        const t = Math.random() * Math.PI * 2;
        const hr = 0.25;
        heartT[i3] = (16 * Math.pow(Math.sin(t), 3)) * hr;
        heartT[i3+1] = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * hr;
        heartT[i3+2] = (Math.random() - 0.5) * 2.5;

        const phi = Math.random() * Math.PI * 2;
        const fR = Math.cos(5 * phi) * 4.5;
        flowerT[i3] = fR * Math.cos(phi);
        flowerT[i3+1] = fR * Math.sin(phi);
        flowerT[i3+2] = Math.sin(fR) * 2;

        const pt = textPoints[i % textPoints.length];
        textT[i3] = pt.x * 1.4; textT[i3+1] = pt.y * 1.4; textT[i3+2] = pt.z;

        pos[i3] = cloudT[i3]; pos[i3+1] = cloudT[i3+1]; pos[i3+2] = cloudT[i3+2];
    }

    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const mat = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true });
    const system = new THREE.Points(geo, mat);
    scene.add(system);

    // 3. SECURE CONTEXT CHECK & CAMERA START
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });

    hands.onResults((res) => {
        statusText.innerText = "VISION: ACTIVE";
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            const up = [8, 12, 16, 20].map(i => lm[i].y < lm[i-2].y);
            const handX = (lm[0].x - 0.5) * -1;
            
            const fist = !up[0] && !up[1] && !up[2] && !up[3];
            const peace = up[0] && up[1] && !up[2] && !up[3];
            const three = up[0] && up[1] && up[2] && !up[3];

            if (fist) { currentMode = 'heart'; modeLabel.innerText = "â¤ï¸ HEART"; targetRotationY = handX * 6; }
            else if (peace) { currentMode = 'flower'; modeLabel.innerText = "ðŸŒ¸ FLOWER"; targetRotationY = handX * 6; }
            else if (three) { currentMode = 'text'; modeLabel.innerText = "âœ¨ I LOVE YOU"; targetRotationY = handX * 6; }
            else { currentMode = 'cloud'; modeLabel.innerText = "SCANNING..."; targetRotationY += 0.005; }
        }
    });

    document.getElementById('activate-cam').addEventListener('click', async () => {
        const errDisplay = document.getElementById('err-display');
        
        // Safety Check for Secure Context
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            errDisplay.style.display = "block";
            errDisplay.innerHTML = "<b>Security Error:</b> Camera is disabled on non-HTTPS sites.<br>Please use GitHub Pages or a secure server.";
            return;
        }

        try {
            document.getElementById('setup-overlay').style.display = 'none';
            const cam = new Camera(document.getElementById('video-input'), {
                onFrame: async () => { await hands.send({image: document.getElementById('video-input')}); },
                width: 640, height: 480
            });
            cam.start();
        } catch (e) {
            errDisplay.style.display = "block";
            errDisplay.innerText = "Camera Access Denied or in use.";
        }
    });

    // 4. ANIMATION LOOP
    function animate() {
        requestAnimationFrame(animate);
        const p = geo.attributes.position.array;
        const c = geo.attributes.color.array;
        system.rotation.y += (targetRotationY - system.rotation.y) * 0.1;

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            let tx, ty, tz, r, g, b;

            if (currentMode === 'heart') { tx = heartT[i3]; ty = heartT[i3+1]; tz = heartT[i3+2]; r = 1; g = 0.1; b = 0.3; }
            else if (currentMode === 'flower') { tx = flowerT[i3]; ty = flowerT[i3+1]; tz = flowerT[i3+2]; r = 1; g = 0.6; b = 0.9; }
            else if (currentMode === 'text') { tx = textT[i3]; ty = textT[i3+1]; tz = textT[i3+2]; r = 0; g = 0.9; b = 1; }
            else { tx = cloudT[i3]; ty = cloudT[i3+1]; tz = cloudT[i3+2]; r = 0.2; g = 0.3; b = 0.5; }

            p[i3] += (tx - p[i3]) * 0.12;
            p[i3+1] += (ty - p[i3+1]) * 0.12;
            p[i3+2] += (tz - p[i3+2]) * 0.12;
            c[i3] += (r - c[i3]) * 0.1; c[i3+1] += (g - c[i3+1]) * 0.1; c[i3+2] += (b - c[i3+2]) * 0.1;
        }
        geo.attributes.position.needsUpdate = true;
        geo.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>